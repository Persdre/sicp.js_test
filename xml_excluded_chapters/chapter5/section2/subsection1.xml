    <SUBSECTION>
      <NAME>
  The Machine Model
      </NAME>

      <LABEL NAME="sec:machine-model"/>

      <TEXT>
  The machine model generated by <SCHEMEINLINE>make-machine</SCHEMEINLINE> is represented as a
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  with local state using the message-passing techniques
  developed in chapter<SPACE/>3.  To build this model, <SCHEMEINLINE>make-machine</SCHEMEINLINE>
  begins by calling the
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>make-new-machine</SCHEMEINLINE> to construct
  the parts of the machine model that are common to all register
  machines.  This basic machine model constructed by <SCHEMEINLINE>make-new-machine</SCHEMEINLINE> is essentially a container for some registers and a
  stack, together with an execution mechanism that processes the controller
  instructions one by one.
      </TEXT>

      <TEXT>
  <SCHEMEINLINE>Make-machine</SCHEMEINLINE> then extends this basic model (by sending it
  messages) to include the registers, operations, and controller of the
  particular machine being defined.  First it allocates a register in
  the new machine for each of the supplied register names and installs
  the designated operations in the machine.  Then it uses an 
  <INDEX>assembler</INDEX>
  <EM>
    assembler</EM> (described below in section<SPACE/><REF NAME="sec:assembler"/>) to
  transform the controller list into instructions for the new machine
  and installs these as the machine<APOS/>s instruction sequence.  <SCHEMEINLINE>Make-machine</SCHEMEINLINE> returns as its value the modified machine model.

  <SNIPPET>
    <SCHEME>
      <!--  \indcode*{make-machine} -->
      (define (make-machine register-names ops controller-text)
      (let ((machine (make-new-machine)))
      (for-each (lambda (register-name)
            ((machine 'allocate-register) register-name))
            register-names)
      ((machine 'install-operations) ops)    
      ((machine 'install-instruction-sequence)
      (assemble controller-text machine))
      machine))
    </SCHEME>
  </SNIPPET>
      </TEXT>

      <SUBHEADING>
  <NAME>Registers</NAME>
      </SUBHEADING>

      <INDEX>register(s)<SUBINDEX>representing</SUBINDEX></INDEX>

      <TEXT>
  We will represent a register as a
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  with local state, as in
  chapter<SPACE/>3.  The
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>make-register</SCHEMEINLINE> creates a register that
  holds a value that can be accessed or changed:

  <SNIPPET>
    <SCHEME>
      <!--  \indcode*{make-register} -->
      (define (make-register name)
      (let ((contents '*unassigned*))
      (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
            (lambda (value) (set! contents value)))
            (else
            (error "Unknown request - - REGISTER" message))))
      dispatch))
    </SCHEME>
  </SNIPPET>
      </TEXT>

      <TEXT>
  The following
  <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
  are used to access registers:

  <SNIPPET>
    <SCHEME>
      <!--  \indcode*{get-contents} -->
      (define (get-contents register)
      (register 'get))

      <!--  \indcode*{set-contents!} -->
      (define (set-contents! register value)
      ((register 'set) value))
    </SCHEME>
  </SNIPPET>
      </TEXT>

      <SUBHEADING>
  <NAME>The stack</NAME>
      </SUBHEADING>

      <INDEX>stack<SUBINDEX>representing</SUBINDEX></INDEX>

      <TEXT>
  We can also represent a stack as a
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  with local state.  The
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>make-stack</SCHEMEINLINE> creates a stack whose local state consists
  of a list of the items on the stack.  A stack accepts requests to <SCHEMEINLINE>push</SCHEMEINLINE> an item onto the stack, to <SCHEMEINLINE>pop</SCHEMEINLINE> the top item off the stack
  and return it, and to <SCHEMEINLINE>initialize</SCHEMEINLINE> the stack to empty.

  <SNIPPET>
    <SCHEME>
      <!--  \indcode*{make-stack} -->
      (define (make-stack)
      (let ((s '()))
      (define (push x)
      (set! s (cons x s)))
      (define (pop)
      (if (null? s)
            (error "Empty stack - - POP")
            (let ((top (car s)))
            (set! s (cdr s))
            top)))
      (define (initialize)
      (set! s '())
      'done)
      (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            (else (error "Unknown request - - STACK"
            message))))
      dispatch))
    </SCHEME>
  </SNIPPET>
      </TEXT>

      <TEXT>
  The following
  <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
  are used to access stacks:

  <SNIPPET>
    <SCHEME>
      <!--  \indcode*{pop} -->
      (define (pop stack)
      (stack 'pop))

      <!--  \indcode*{push} -->
      (define (push stack value)
      ((stack 'push) value))
    </SCHEME>
  </SNIPPET>
      </TEXT>

      <SUBHEADING>
  <NAME>The basic machine</NAME>
      </SUBHEADING>

      <TEXT>
  The <SCHEMEINLINE>make-new-machine</SCHEMEINLINE>
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, shown in
  figure<SPACE/><REF NAME="fig:make-new-machine"/>, constructs an object whose local
  state consists of a stack, an initially empty instruction sequence, a
  list of operations that initially contains an operation to 
  <!-- \indcodeplus{initialize-stack}{operation in register machine}-->
  initialize
  the stack, and a 
  <INDEX>register table, in simulator</INDEX>
  <EM>register table</EM> that initially contains two
  <!-- \indcodeplus{flag}{register}-->
  <!-- \indcodeplus{pc}{register}-->
  registers, named <SCHEMEINLINE>flag</SCHEMEINLINE> and <SCHEMEINLINE>pc</SCHEMEINLINE> 
  <INDEX>program counter</INDEX>
  (for <QUOTE>program counter</QUOTE>).
  The internal
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>allocate-register</SCHEMEINLINE> adds new entries to the
  register table, and the internal
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>lookup-register</SCHEMEINLINE> looks
  up registers in the table.
      </TEXT>

      <TEXT>
  The <SCHEMEINLINE>flag</SCHEMEINLINE> register is used to control branching in the simulated
  machine.  <SCHEMEINLINE>Test</SCHEMEINLINE> instructions set the contents of <SCHEMEINLINE>flag</SCHEMEINLINE> to
  the result of the test (true or false).  <SCHEMEINLINE>Branch</SCHEMEINLINE> instructions
  decide whether or not to branch by examining the contents of <SCHEMEINLINE>flag</SCHEMEINLINE>.
      </TEXT>

      <TEXT>
  The <SCHEMEINLINE>pc</SCHEMEINLINE> register determines the sequencing of instructions as
  the machine runs.  This sequencing is implemented by the internal
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SCHEMEINLINE>execute</SCHEMEINLINE>.
  In the simulation model, each machine instruction is a data structure
  that includes a
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  of no arguments, called the 
  <INDEX>instruction execution
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE></INDEX>
  <INDEX>execution
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>in register-machine simulator</SUBINDEX></INDEX>
  <EM>instruction
    execution
    <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE></EM>, such that calling this
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  simulates
  executing the instruction.  As the simulation runs, <SCHEMEINLINE>pc</SCHEMEINLINE> points to
  the place in the instruction sequence beginning with the next
  instruction to be executed.  
  <!--  \indcode{execute} -->
  <SCHEMEINLINE>Execute</SCHEMEINLINE> gets that instruction,
  executes it by calling the instruction execution
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, and
  repeats this cycle until there are no more instructions to execute
  (i.e., until <SCHEMEINLINE>pc</SCHEMEINLINE> points to the end of the instruction sequence).

  \begin{figure}
  <SNIPPET>
    <SCHEME>
      <!--  \indcode*{make-new-machine} -->
      (define (make-new-machine)
      (let ((pc (make-register 'pc))
            (flag (make-register 'flag))
            (stack (make-stack))
            (the-instruction-sequence '()))
      (let ((the-ops
            (list (list 'initialize-stack
            (lambda () (stack 'initialize)))))
            (register-table
            (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
            (if (assoc name register-table)
            (error "Multiply defined register: " name)
            (set! register-table
            (cons (list name (make-register name))
            register-table)))
            'register-allocated)
      (define (lookup-register name)
            (let ((val (assoc name register-table)))
            (if val
            (cadr val)
            (error "Unknown register:" name))))
      (define (execute)
            (let ((insts (get-contents pc)))
            (if (null? insts)
            'done
            (begin
            ((instruction-execution-proc (car insts)))
            (execute)))))
      (define (dispatch message)
            (cond ((eq? message 'start)
            (set-contents! pc the-instruction-sequence)
            (execute))
            ((eq? message 'install-instruction-sequence)
            (lambda (seq) (set! the-instruction-sequence seq)))
            ((eq? message 'allocate-register) allocate-register)
            ((eq? message 'get-register) lookup-register)
            ((eq? message 'install-operations)
            (lambda (ops) (set! the-ops (append the-ops ops))))
            ((eq? message 'stack) stack)
            ((eq? message 'operations) the-ops)
            (else (error "Unknown request - - MACHINE" message))))
      dispatch)))
    </SCHEME>
  </SNIPPET>
  \vskip -10pt
  \figcaption {The <SCHEMEINLINE>make-new-machine</SCHEMEINLINE>
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>, which implements
  the basic machine model.}
  <LABEL NAME="fig:make-new-machine"/>
  \end{figure}
      </TEXT>

      <TEXT>
  As part of its operation, each instruction execution
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  modifies <SCHEMEINLINE>pc</SCHEMEINLINE> to indicate the next instruction to be executed.
  <SCHEMEINLINE>Branch</SCHEMEINLINE> and <SCHEMEINLINE>goto</SCHEMEINLINE> instructions change <SCHEMEINLINE>pc</SCHEMEINLINE> to point to
  the new destination.  All other instructions simply advance <SCHEMEINLINE>pc</SCHEMEINLINE>,
  making it point to the next instruction in the sequence.  Observe that
  each call to <SCHEMEINLINE>execute</SCHEMEINLINE> calls <SCHEMEINLINE>execute</SCHEMEINLINE> again, but this does
  not produce an infinite loop because running the instruction execution
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  changes the contents of <SCHEMEINLINE>pc</SCHEMEINLINE>.
      </TEXT>

      <TEXT>
  <SCHEMEINLINE>Make-new-machine</SCHEMEINLINE> returns a
  <SCHEMEINLINE>dispatch</SCHEMEINLINE>
  <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  that implements message-passing
  access to the internal state.  Notice that starting the machine is
  accomplished by setting <SCHEMEINLINE>pc</SCHEMEINLINE> to the beginning of the instruction
  sequence and calling <SCHEMEINLINE>execute</SCHEMEINLINE>.
      </TEXT>

      <TEXT>
  For convenience, we provide an alternate procedural interface to a
  machine<APOS/>s <SCHEMEINLINE>start</SCHEMEINLINE> operation,
  as well as
  <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
  to set and examine register contents,
  as specified at the beginning of section<SPACE/><REF NAME="sec:simulator"/>:

  <SNIPPET>
    <SCHEME>
      <!-- \indcodeplus*{start}{register machine}-->
      (define (start machine)
      (machine 'start))

      <!--  \indcode*{get-register-contents} -->
      (define (get-register-contents machine register-name)
      (get-contents (get-register machine register-name)))

      <!--  \indcode*{set-register-contents!} -->
      (define (set-register-contents! machine register-name value)
      (set-contents! (get-register machine register-name) value)
      'done)
    </SCHEME>
  </SNIPPET>
      </TEXT>

      <TEXT>
  These
  <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
  (and many
  <SPLITINLINE><SCHEME>procedures</SCHEME><JAVASCRIPT>functions</JAVASCRIPT></SPLITINLINE>
  in sections<SPACE/><REF NAME="sec:assembler"/>
  and <REF NAME="sec:ex-proc"/>) use the following to look up the register with a
  given name in a given machine:
  <SNIPPET>
    <SCHEME>
      <!--  \indcode*{get-register} -->
      (define (get-register machine reg-name)
      ((machine 'get-register) reg-name))
    </SCHEME>
  </SNIPPET>
      </TEXT>

    </SUBSECTION>
